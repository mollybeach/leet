##when to use which algorithm
    BFS: when you want to find the shortest path between two vertices
    DFS: when you want to find all the paths between two vertices
    Dijkstra: when you want to find the shortest path between two vertices
    Floyd Warshall: when you want to find the shortest path between all vertices
    Topological Sort: when you want to find the order of vertices in a directed acyclic graph
    Prim: when you want to find the minimum spanning tree of a graph
    Kruskal: when you want to find the minimum spanning tree of a graph
    Bellman-Ford: when you want to find the shortest path between two vertices in a graph with negative weights
    A*: when you want to find the shortest path between two vertices in a graph with negative weights
    Sliding Window: when you want to find the longest substring with no repeating characters
    Merge Intervals: when you want to merge overlapping intervals
    
##when to use which data structure
    Stack: when you want to store a list of elements and access them in a LIFO order
    Queue: when you want to store a list of elements and access them in a FIFO order
    Set: when you want to store a list of unique elements
    Map: when you want to store a list of key-value pairs
    Linked List: when you want to store a list of elements and access them in a sequential order
    Doubly Linked List: when you want to store a list of elements and access them in a sequential order
    Binary Search Tree: when you want to store a list of elements and access them in a sorted order
    Heap: when you want to store a list of elements and access them in a sorted order
    Graph: when you want to store a list of vertices and edges
    Hash Table: when you want to store a list of key-value pairs and access them in a constant time
    
##when to use which sorting algorithm
    Bubble Sort: when you want to sort a list of elements in ascending order
    Selection Sort: when you want to sort a list of elements in ascending order
    Insertion Sort: when you want to sort a list of elements in ascending order
    Merge Sort: when you want to sort a list of elements in ascending order
    Quick Sort: when you want to sort a list of elements in ascending order
    Heap Sort: when you want to sort a list of elements in ascending order
    Bucket Sort: when you want to sort a list of elements in ascending order
    Radix Sort: when you want to sort a list of elements in ascending order
    
##when to use which searching algorithm
    Linear Search: when you want to search for an element in a list of elements
    Binary Search: when you want to search for an element in a sorted list of elements
    Breadth First Search: when you want to search for an element in a graph
    Depth First Search: when you want to search for an element in a graph
    Hash Table: when you want to search for an element in a list of key-value pairs
    
##when to use which pattern
    Singleton: when you want to restrict the instantiation of a class to one object
    Factory: when you want to create objects without exposing the instantiation logic to the client
    Observer: when you want to create a subscription model to notify multiple objects about any events that happen to the object they are observing
    Mediator: when you want to reduce coupling between classes that communicate with each other. Instead of classes communicating with each other, the classes will communicate with a mediator object
    Decorator: when you want to add new functionality to an existing object without altering its structure
    
##when to use which design principle
    Single Responsibility Principle: when you want to make sure that a class has only one reason to change
    Open-Closed Principle: when you want to make sure that a class is open for extension but closed for modification
    Liskov Substitution Principle: when you want to make sure that a subclass can be used in place of its parent class without breaking the application
    Interface Segregation Principle: when you want to make sure that a class only implements the methods that it needs
    Dependency Inversion Principle: when you want to make sure that a class depends on abstraction and not on concretion
    
##when to use which design pattern
    Factory: when you want to create objects without exposing the instantiation logic to the client
    Abstract Factory: when you want to create families of related objects without exposing the instantiation logic to the client
    Builder: when you want to separate the construction of a complex object from its representation so that the same construction process can create different representations
    Prototype: when you want to create objects based on a template of an existing object through cloning
    Singleton: when you want to restrict the instantiation of a class to one object
    Adapter: when you want to convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces
    Bridge: when you want to decouple an abstraction from its implementation so that the two can vary independently
    Composite: when you want to compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly
    Decorator: when you want to add new functionality to an existing object without altering its structure
    Facade: when you want to provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use
    Flyweight: when you want to use sharing to support large numbers of fine-grained objects efficiently
    Proxy: when you want to provide a placeholder for another object to control access, reduce cost, and reduce complexity
    Chain of Responsibility: when you want to avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it
    Command: when you want to parameterize objects with commands
    Interpreter: when you want to define a representation for a grammar of the given language, along with an interpreter that uses the representation to interpret sentences in the language
    Iterator: when you want to provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation
    Mediator: when you want to reduce coupling between classes that communicate with each other. Instead of classes communicating with each other, the classes will communicate with a mediator object
    Memento: when you want to capture and externalize an object's internal state so that the object can be restored to this state later, without violating encapsulation
    Observer: when you want to create a subscription model to notify multiple objects about any events that happen to the object they are observing
    State: when you want an object to alter its behavior when its internal state changes. The object will appear to change its class
    Strategy: when you want to define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it
    Template Method: when you want to define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure
    Visitor: when you want to define a new operation to a class without changing the class. You want to separate an algorithm from an object structure on which it operates
    
    
    